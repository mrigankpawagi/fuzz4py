{
    "apis": [
        {
            "description": "A generic class that represents the system's path flavour.",
            "name": "pathlib.PurePath",
            "signature": "PurePath(*pathsegments)"
        },
        {
            "description": "A subclass of \"PurePath\", this path flavour represents non-Windows filesystem paths.",
            "name": "pathlib.PurePosixPath",
            "signature": "PurePosixPath(*pathsegments)"
        },
        {
            "description": "A subclass of \"PurePath\", this path flavour represents Windows filesystem paths, including UNC paths.",
            "name": "pathlib.PureWindowsPath",
            "signature": "PureWindowsPath(*pathsegments)"
        },
        {
            "description": "A tuple giving access to the path's various components.",
            "name": "pathlib.PurePath.parts",
            "signature": "parts"
        },
        {
            "description": "The implementation of the \"os.path\" module used for low-level path parsing and joining: either \"posixpath\" or \"ntpath\".",
            "name": "pathlib.PurePath.parser",
            "signature": "parser"
        },
        {
            "description": "A string representing the drive letter or name, if any.",
            "name": "pathlib.PurePath.drive",
            "signature": "drive"
        },
        {
            "description": "A string representing the root, if any.",
            "name": "pathlib.PurePath.root",
            "signature": "root"
        },
        {
            "description": "The concatenation of the drive and root.",
            "name": "pathlib.PurePath.anchor",
            "signature": "anchor"
        },
        {
            "description": "An immutable sequence providing access to the logical ancestors of the path.",
            "name": "pathlib.PurePath.parents",
            "signature": "parents"
        },
        {
            "description": "The logical parent of the path.",
            "name": "pathlib.PurePath.parent",
            "signature": "parent"
        },
        {
            "description": "A string representing the final path component, excluding the drive and root, if any.",
            "name": "pathlib.PurePath.name",
            "signature": "name"
        },
        {
            "description": "The file extension.",
            "name": "pathlib.PurePath.suffix",
            "signature": "suffix"
        },
        {
            "description": "A list of the path's suffixes.",
            "name": "pathlib.PurePath.suffixes",
            "signature": "suffixes"
        },
        {
            "description": "The final path component, without its suffix.",
            "name": "pathlib.PurePath.stem",
            "signature": "stem"
        },
        {
            "description": "Return a string representation of the path with forward slashes (\"/\").",
            "name": "pathlib.PurePath.as_posix",
            "signature": "as_posix()"
        },
        {
            "description": "Return whether the path is absolute or not.",
            "name": "pathlib.PurePath.is_absolute",
            "signature": "is_absolute()"
        },
        {
            "description": "Return whether or not this path is relative to the *other* path.",
            "name": "pathlib.PurePath.is_relative_to",
            "signature": "is_relative_to(other)"
        },
        {
            "description": "Return \"True\" if the path is considered reserved under Windows, \"False\" otherwise. With \"PurePosixPath\", \"False\" is always returned.",
            "name": "pathlib.PurePath.is_reserved",
            "signature": "is_reserved()"
        },
        {
            "description": "Calling this method is equivalent to combining the path with each of the given *pathsegments* in turn.",
            "name": "pathlib.PurePath.joinpath",
            "signature": "joinpath(*pathsegments)"
        },
        {
            "description": "Match this path against the provided glob-style pattern.",
            "name": "pathlib.PurePath.full_match",
            "signature": "full_match(pattern, *, case_sensitive=None)"
        },
        {
            "description": "Match this path against the provided glob-style pattern.",
            "name": "pathlib.PurePath.match",
            "signature": "match(pattern, *, case_sensitive=None)"
        },
        {
            "description": "Compute a version of this path relative to the path represented by *other*.",
            "name": "pathlib.PurePath.relative_to",
            "signature": "relative_to(other, walk_up=False)"
        },
        {
            "description": "Return a new path with the file name changed.",
            "name": "pathlib.PurePath.with_name",
            "signature": "with_name(name)"
        },
        {
            "description": "Return a new path with the \"stem\" changed.",
            "name": "pathlib.PurePath.with_stem",
            "signature": "with_stem(stem)"
        },
        {
            "description": "Return a new path with the file extension changed.",
            "name": "pathlib.PurePath.with_suffix",
            "signature": "with_suffix(suffix)"
        },
        {
            "description": "Create a new path object of the same type by combining the given *pathsegments*.",
            "name": "pathlib.PurePath.with_segments",
            "signature": "with_segments(*pathsegments)"
        },
        {
            "description": "A subclass of \"PurePath\", this class represents concrete paths of the system's path flavour.",
            "name": "pathlib.Path",
            "signature": "Path(*pathsegments)"
        },
        {
            "description": "A subclass of \"Path\" and \"PurePosixPath\", this class represents concrete non-Windows filesystem paths.",
            "name": "pathlib.PosixPath",
            "signature": "PosixPath(*pathsegments)"
        },
        {
            "description": "A subclass of \"Path\" and \"PureWindowsPath\", this class represents concrete Windows filesystem paths.",
            "name": "pathlib.WindowsPath",
            "signature": "WindowsPath(*pathsegments)"
        },
        {
            "description": "Return a new path object from parsing a 'file' URI.",
            "name": "pathlib.Path.from_uri",
            "signature": "from_uri(uri)"
        },
        {
            "description": "Represent the path as a 'file' URI.",
            "name": "pathlib.Path.as_uri",
            "signature": "as_uri()"
        },
        {
            "description": "Return a new path object representing the user's home directory.",
            "name": "pathlib.Path.home",
            "signature": "home()"
        },
        {
            "description": "Return a new path with expanded \"~\" and \"~user\" constructs.",
            "name": "pathlib.Path.expanduser",
            "signature": "expanduser()"
        },
        {
            "description": "Return a new path object representing the current directory.",
            "name": "pathlib.Path.cwd",
            "signature": "cwd()"
        },
        {
            "description": "Make the path absolute, without normalization or resolving symlinks.",
            "name": "pathlib.Path.absolute",
            "signature": "absolute()"
        },
        {
            "description": "Make the path absolute, resolving any symlinks.",
            "name": "pathlib.Path.resolve",
            "signature": "resolve(strict=False)"
        },
        {
            "description": "Return the path to which the symbolic link points.",
            "name": "pathlib.Path.readlink",
            "signature": "readlink()"
        },
        {
            "description": "Return an \"os.stat_result\" object containing information about this path.",
            "name": "pathlib.Path.stat",
            "signature": "stat(*, follow_symlinks=True)"
        },
        {
            "description": "Like \"Path.stat()\" but, if the path points to a symbolic link, return the symbolic link's information rather than its target's.",
            "name": "pathlib.Path.lstat",
            "signature": "lstat()"
        },
        {
            "description": "Return \"True\" if the path points to an existing file or directory.",
            "name": "pathlib.Path.exists",
            "signature": "exists(*, follow_symlinks=True)"
        },
        {
            "description": "Return \"True\" if the path points to a regular file, \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_file",
            "signature": "is_file(*, follow_symlinks=True)"
        },
        {
            "description": "Return \"True\" if the path points to a directory (or a symbolic link pointing to a directory), \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_dir",
            "signature": "is_dir(*, follow_symlinks=True)"
        },
        {
            "description": "Return \"True\" if the path points to a symbolic link, \"False\" otherwise.",
            "name": "pathlib.Path.is_symlink",
            "signature": "is_symlink()"
        },
        {
            "description": "Return \"True\" if the path points to a junction, and \"False\" for any other type of file.",
            "name": "pathlib.Path.is_junction",
            "signature": "is_junction()"
        },
        {
            "description": "Return \"True\" if the path is a *mount point*.",
            "name": "pathlib.Path.is_mount",
            "signature": "is_mount()"
        },
        {
            "description": "Return \"True\" if the path points to a Unix socket, \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_socket",
            "signature": "is_socket()"
        },
        {
            "description": "Return \"True\" if the path points to a FIFO, \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_fifo",
            "signature": "is_fifo()"
        },
        {
            "description": "Return \"True\" if the path points to a block device, \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_block_device",
            "signature": "is_block_device()"
        },
        {
            "description": "Return \"True\" if the path points to a character device, \"False\" if it points to another kind of file.",
            "name": "pathlib.Path.is_char_device",
            "signature": "is_char_device()"
        },
        {
            "description": "Return whether this path points to the same file as *other_path*.",
            "name": "pathlib.Path.samefile",
            "signature": "samefile(other_path)"
        },
        {
            "description": "Open the file pointed by the path.",
            "name": "pathlib.Path.open",
            "signature": "open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)"
        },
        {
            "description": "Open the file in text mode, read it, and close the file.",
            "name": "pathlib.Path.read_text",
            "signature": "read_text(encoding=None, errors=None, newline=None)"
        },
        {
            "description": "Open the file in binary/bytes mode, read it, and close the file.",
            "name": "pathlib.Path.read_bytes",
            "signature": "read_bytes()"
        },
        {
            "description": "Open the file pointed to in text mode, write *data* to it, and close the file.",
            "name": "pathlib.Path.write_text",
            "signature": "write_text(data, encoding=None, errors=None, newline=None)"
        },
        {
            "description": "Open the file pointed to in binary mode, write *data* to it, and close the file.",
            "name": "pathlib.Path.write_bytes",
            "signature": "write_bytes(data)"
        },
        {
            "description": "When the path points to a directory, yield path objects of the directory contents.",
            "name": "pathlib.Path.iterdir",
            "signature": "iterdir()"
        },
        {
            "description": "Glob the given relative *pattern* in the directory represented by this path.",
            "name": "pathlib.Path.glob",
            "signature": "glob(pattern, *, case_sensitive=None, recurse_symlinks=False)"
        },
        {
            "description": "This is like calling \"Path.glob()\" with \"**/\" added in front of the given relative *pattern*.",
            "name": "pathlib.Path.rglob",
            "signature": "rglob(pattern, *, case_sensitive=None, recurse_symlinks=False)"
        },
        {
            "description": "Generate the file names in a directory tree by walking the tree either top-down or bottom-up.",
            "name": "pathlib.Path.walk",
            "signature": "walk(top_down=True, on_error=None, follow_symlinks=False)"
        },
        {
            "description": "Create a file at this given path.",
            "name": "pathlib.Path.touch",
            "signature": "touch(mode=0o666, exist_ok=True)"
        },
        {
            "description": "Create a new directory at this given path.",
            "name": "pathlib.Path.mkdir",
            "signature": "mkdir(mode=0o777, parents=False, exist_ok=False)"
        },
        {
            "description": "Make this path a symbolic link pointing to *target*.",
            "name": "pathlib.Path.symlink_to",
            "signature": "symlink_to(target, target_is_directory=False)"
        },
        {
            "description": "Make this path a hard link pointing to *target*.",
            "name": "pathlib.Path.hardlink_to",
            "signature": "hardlink_to(target)"
        },
        {
            "description": "Rename this file or directory to the given *target*, and return a new \"Path\" instance pointing to *target*.",
            "name": "pathlib.Path.rename",
            "signature": "rename(target)"
        },
        {
            "description": "Rename this file or directory to the given *target*, and return a new \"Path\" instance pointing to *target*. If *target* points to an existing file or directory, it will be unconditionally replaced.",
            "name": "pathlib.Path.replace",
            "signature": "replace(target)"
        },
        {
            "description": "Remove this file or symbolic link.",
            "name": "pathlib.Path.unlink",
            "signature": "unlink(missing_ok=False)"
        },
        {
            "description": "Remove this directory.  The directory must be empty.",
            "name": "pathlib.Path.rmdir",
            "signature": "rmdir()"
        },
        {
            "description": "Return the name of the user owning the file.",
            "name": "pathlib.Path.owner",
            "signature": "owner(*, follow_symlinks=True)"
        },
        {
            "description": "Return the name of the group owning the file.",
            "name": "pathlib.Path.group",
            "signature": "group(*, follow_symlinks=True)"
        },
        {
            "description": "Change the file mode and permissions.",
            "name": "pathlib.Path.chmod",
            "signature": "chmod(mode, *, follow_symlinks=True)"
        },
        {
            "description": "Like \"Path.chmod()\" but, if the path points to a symbolic link, the symbolic link's mode is changed rather than its target's.",
            "name": "pathlib.Path.lchmod",
            "signature": "lchmod(mode)"
        }
    ]
}